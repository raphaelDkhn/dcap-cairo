This file is a merged representation of the entire codebase of TDX Cairo Verifier, combining all repository files into a single document.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
contract/
  src/
    lib.cairo
  tests/
    test_contract.cairo
  Scarb.toml
crates/
  preprocess/
    src/
      lib.rs
      parser.rs
      types.rs
    Cargo.toml
dcap-cairo/
  src/
    common/
      bytes.cairo
    common.cairo
    constants.cairo
    lib.cairo
    types.cairo
  Scarb.toml
scripts/
  gen_test_data/
    data/
    src/
      main.rs
    Cargo.toml
.gitignore
.tool-versions
README.md

================================================================
Repository Files
================================================================

================
File: contract/src/lib.cairo
================
use dcap_cairo::types::{QuoteHeader, TD10ReportBody, AttestationPubKey, TdxModule};
use core::starknet::secp256_trait::Signature;

#[starknet::interface]
pub trait ITdxVerifier<TContractState> {
    fn verify_tdx(
        self: @TContractState,
        quote_header: QuoteHeader,
        quote_body: TD10ReportBody,
        attestation_signature: Signature,
        attestation_pubkey: AttestationPubKey,
        tdx_module: TdxModule,
        tcb_info_svn: Span<u8>,
    ) -> bool;
}

#[starknet::contract]
mod TdxVerifier {
    use super::{QuoteHeader, TD10ReportBody, Signature, TdxModule, AttestationPubKey};
    use dcap_cairo::{verify_quote_signature, verify_tdx_module, verify_tdx_tcb};

    #[storage]
    struct Storage {}


    #[abi(embed_v0)]
    impl TdxVerifierImpl of super::ITdxVerifier<ContractState> {
        fn verify_tdx(
            self: @ContractState,
            quote_header: QuoteHeader,
            quote_body: TD10ReportBody,
            attestation_signature: Signature,
            attestation_pubkey: AttestationPubKey,
            tdx_module: TdxModule,
            tcb_info_svn: Span<u8>,
        ) -> bool {
            // Verify quote signature
            if !verify_quote_signature(
                @quote_header, @quote_body, @attestation_signature, attestation_pubkey,
            ) {
                return false;
            }

            // Verify TDX module identity
            if !verify_tdx_module(@quote_body, @tdx_module) {
                return false;
            }

            // Get TCB status from TDX module verification
            let tcb_status = verify_tdx_tcb(quote_body.tee_tcb_svn, @tdx_module);
            if tcb_status != 0 {
                return false;
            }

            true
        }
    }
}

================
File: contract/tests/test_contract.cairo
================
use starknet::ContractAddress;

use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};

use tdx_verifier::ITdxVerifierDispatcher;
use tdx_verifier::ITdxVerifierDispatcherTrait;
use dcap_cairo::types::{
    QuoteHeader, TD10ReportBody, AttestationPubKey, TdxModule, TdxModuleIdentityTcbLevel,
    TdxModuleTcb
};
use core::starknet::secp256_trait::Signature;

fn deploy_contract(name: ByteArray) -> ContractAddress {
    let contract = declare(name).unwrap().contract_class();
    let (contract_address, _) = contract.deploy(@ArrayTrait::new()).unwrap();
    contract_address
}

#[test]
fn test_verify_tdx() {
    let contract_address = deploy_contract("TdxVerifier");
    let dispatcher = ITdxVerifierDispatcher { contract_address };

    let quote_header = QuoteHeader {
        version: 4,
        att_key_type: 2,
        tee_type: 129,
        qe_svn: [0, 0].span(),
        pce_svn: [0, 0].span(),
        qe_vendor_id: [147, 154, 114, 51, 247, 156, 76, 169, 148, 10, 13, 179, 149, 127, 6, 7].span(),
        user_data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span()
    };
    let quote_body = TD10ReportBody {
        tee_tcb_svn: [4, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        mrseam: [255, 201, 122, 136, 88, 118, 96, 251, 4, 225, 247, 200, 81, 48, 12, 150, 174, 11, 90, 70, 58, 196, 109, 3, 93, 22, 194, 217, 243, 109, 14, 209, 210, 55, 117, 188, 189, 39, 222, 178, 25, 227, 163, 204, 40, 2, 56, 149].span(),
        mrsignerseam: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        seam_attributes: 0,
        td_attributes: 268435456,
        xfam: 393447,
        mrtd: [147, 91, 231, 116, 45, 216, 156, 106, 77, 246, 219, 168, 53, 61, 137, 4, 26, 224, 240, 82, 190, 239, 153, 59, 30, 127, 69, 36, 211, 188, 87, 101, 13, 242, 14, 85, 130, 21, 131, 82, 225, 36, 11, 63, 31, 237, 85, 216].span(),
        mrconfigid: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        mrowner: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        mrownerconfig: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        rtmr0: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        rtmr1: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        rtmr2: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        rtmr3: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        report_data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
    };
    let attestation_signature = Signature { 
        r: 93365417596392173216615325329090662873203166825266999052552765068694785025080, 
        s: 41274054662607370920022648988298732045244729835348055072969625109080248134816, 
        y_parity: false 
    };
    let attestation_pubkey = AttestationPubKey { 
        x: 89521682765195554316697216516807714906060301894091276041900222659568441588538, 
        y: 77304533788128125567500712966575947581765564830032369733143882782798476817024 
    };
    let tdx_module = TdxModule {
        mrsigner: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span(),
        attributes: 0,
        attributes_mask: 18446744073709551615,
        identity_id: 'TDX_01',
        expected_id: 'TDX_01',
        tcb_levels: [TdxModuleIdentityTcbLevel { tcb: TdxModuleTcb { isvsvn: 2 }, tcb_status: 0 }].span()
    };
    let tcb_info_svn = [3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].span();
    

    let is_valid = dispatcher.verify_tdx(
        quote_header,
        quote_body,
        attestation_signature,
        attestation_pubkey,
        tdx_module,
        tcb_info_svn
    );
    assert(is_valid == true, 'quote not valid');
}

================
File: contract/Scarb.toml
================
[package]
name = "tdx_verifier"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.8.4"
dcap_cairo = {path = "../dcap-cairo"}

[dev-dependencies]
snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry", tag = "v0.33.0" }
assert_macros = "2.8.4"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# Visit https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html for more information

# [tool.snforge]                                             # Define `snforge` tool section
# exit_first = true                                          # Stop tests execution immediately upon the first failure
# fuzzer_runs = 1234                                         # Number of runs of the random fuzzer
# fuzzer_seed = 1111                                         # Seed for the random fuzzer

# [[tool.snforge.fork]]                                      # Used for fork testing
# name = "SOME_NAME"                                         # Fork name
# url = "http://your.rpc.url"                                # Url of the RPC provider
# block_id.tag = "latest"                                    # Block to fork from (block tag)

# [[tool.snforge.fork]]
# name = "SOME_SECOND_NAME"
# url = "http://your.second.rpc.url"                         
# block_id.number = "123"                                    # Block to fork from (block number)

# [[tool.snforge.fork]]
# name = "SOME_THIRD_NAME"
# url = "http://your.third.rpc.url"
# block_id.hash = "0x123"                                    # Block to fork from (block hash)

# [profile.dev.cairo]                                        # Configure Cairo compiler
# unstable-add-statements-code-locations-debug-info = true   # Should be used if you want to use coverage
# unstable-add-statements-functions-debug-info = true        # Should be used if you want to use coverage/profiler
# inlining-strategy = "avoid"                                # Should be used if you want to use coverage

# [features]                                                 # Used for conditional compilation
# enable_for_tests = []                                      # Feature name and list of other features that should be enabled with it

================
File: crates/preprocess/src/lib.rs
================
pub mod types;
pub mod parser;

================
File: crates/preprocess/src/parser.rs
================
use dcap_rs::types::{
    collaterals::IntelCollateral,
    quotes::{body::QuoteBody, version_4::QuoteV4},
};
use ethnum::u256;

use crate::types::{
    AttestationPubKey, ContractInputs, QuoteHeader, Signature, TD10ReportBody, TdxModule,
    TdxModuleIdentityTcbLevel, TdxModuleTcb,
};

pub fn prepare_cairo_inputs(quote: &QuoteV4, collaterals: &IntelCollateral) -> ContractInputs {
    // Extract quote header
    let cairo_header = QuoteHeader {
        version: quote.header.version,
        att_key_type: quote.header.att_key_type,
        tee_type: quote.header.tee_type,
        qe_svn: quote.header.qe_svn.to_vec(),
        pce_svn: quote.header.pce_svn.to_vec(),
        qe_vendor_id: quote.header.qe_vendor_id.to_vec(),
        user_data: quote.header.user_data.to_vec(),
    };

    // Extract TD10 report body
    let td10_body = if let QuoteBody::TD10QuoteBody(body) = quote.quote_body {
        TD10ReportBody {
            tee_tcb_svn: body.tee_tcb_svn.to_vec(),
            mrseam: body.mrseam.to_vec(),
            mrsignerseam: body.mrsignerseam.to_vec(),
            seam_attributes: body.seam_attributes,
            td_attributes: body.td_attributes,
            xfam: body.xfam,
            mrtd: body.mrtd.to_vec(),
            mrconfigid: body.mrconfigid.to_vec(),
            mrowner: body.mrowner.to_vec(),
            mrownerconfig: body.mrownerconfig.to_vec(),
            rtmr0: body.rtmr0.to_vec(),
            rtmr1: body.rtmr1.to_vec(),
            rtmr2: body.rtmr2.to_vec(),
            rtmr3: body.rtmr3.to_vec(),
            report_data: body.report_data.to_vec(),
        }
    } else {
        panic!("Not a TD10 quote body");
    };

    // Extract ECDSA signature
    let signature = {
        let sig = &quote.signature.quote_signature;
        let (r, s) = sig.split_at(32);

        // Convert both parts of the signature
        let r_u256 = u256::from_le_bytes(*try_into_array(r).unwrap());
        let s_u256 = u256::from_le_bytes(*try_into_array(s).unwrap());

        // Create the signature struct
        Signature {
            r: r_u256,
            s: s_u256,
            y_parity: false,
        }
    };

    // Get attestation public key
    let pubkey = {
        let key = &quote.signature.ecdsa_attestation_key;
        let (x, y) = key.split_at(32);
        AttestationPubKey {
            x: u256::from_le_bytes(*try_into_array(x).unwrap()),
            y: u256::from_le_bytes(*try_into_array(y).unwrap()),
        }
    };

    // Extract TDX module info from TCBInfo
    let tcbinfo_v3 = collaterals.get_tcbinfov3();
    let tdx_module = if let Some(module) = &tcbinfo_v3.tcb_info.tdx_module {
        // Get version from quote's TEE TCB SVN
        let tdx_module_version = if let QuoteBody::TD10QuoteBody(ref body) = quote.quote_body {
            body.tee_tcb_svn[1]
        } else {
            panic!("Not a TD10 quote body");
        };

        // Pre-format the expected module ID
        let expected_id = format!("TDX_{:02x}", tdx_module_version);

        // Collect TCB levels and get module ID for the matching version
        let mut levels = Vec::new();
        let mut identity_id = String::new();

        if let Some(identities) = &tcbinfo_v3.tcb_info.tdx_module_identities {
            for identity in identities {
                if identity.id == expected_id {
                    identity_id = identity.id.clone(); // Get the ID from matching identity
                    for level in &identity.tcb_levels {
                        levels.push(TdxModuleIdentityTcbLevel {
                            tcb: TdxModuleTcb {
                                isvsvn: level.tcb.isvsvn,
                            },
                            tcb_status: match level.tcb_status.as_str() {
                                "UpToDate" => 0,
                                "SWHardeningNeeded" => 1,
                                "ConfigurationNeeded" => 2,
                                "ConfigurationAndSWHardeningNeeded" => 3,
                                "OutOfDate" => 4,
                                "OutOfDateConfigurationNeeded" => 5,
                                "Revoked" => 6,
                                _ => 7, // UNRECOGNIZED
                            },
                        });
                    }
                }
            }
        }
        levels.sort_by(|a, b| b.tcb.isvsvn.cmp(&a.tcb.isvsvn));

        let mrsigner = hex::decode(&module.mrsigner).unwrap();
        let mut mrsigner_bytes = [0u8; 48];
        mrsigner_bytes.copy_from_slice(&mrsigner);

        TdxModule {
            mrsigner: mrsigner_bytes.to_vec(),
            attributes: u64::from_str_radix(&module.attributes, 16).unwrap(),
            attributes_mask: u64::from_str_radix(&module.attributes_mask, 16).unwrap(),
            identity_id, // Get ID from matching identity
            expected_id, // Expected ID based on version
            tcb_levels: levels,
        }
    } else {
        panic!("No TDX module in TCBInfo");
    };

    // Get TCB SVN values for comparison
    let tcb_info_svn = if let Some(tcb_level) = tcbinfo_v3.tcb_info.tcb_levels.first() {
        if let Some(tdx_components) = &tcb_level.tcb.tdxtcbcomponents {
            tdx_components.iter().map(|comp| comp.svn as u8).collect()
        } else {
            Vec::new()
        }
    } else {
        panic!("No TCB levels found");
    };

    ContractInputs {
        quote_header: cairo_header,
        quote_body: td10_body,
        attestation_signature: signature,
        attestation_pubkey: pubkey,
        tdx_module,
        tcb_info_svn,
    }
}

// Helper function to convert slice &[u8] to &[u8; 32]
fn try_into_array(slice: &[u8]) -> Result<&[u8; 32], &'static str> {
    if slice.len() == 32 {
        let ptr = slice.as_ptr() as *const [u8; 32];
        unsafe { Ok(&*ptr) }
    } else {
        Err("Slice must be exactly 32 bytes long")
    }
}

================
File: crates/preprocess/src/types.rs
================
use ethnum::u256;

pub struct QuoteHeader {
    pub version: u16,
    pub att_key_type: u16,
    pub tee_type: u32,
    pub qe_svn: Vec<u8>,       // 2 bytes
    pub pce_svn: Vec<u8>,      // 2 bytes
    pub qe_vendor_id: Vec<u8>, // 16 bytes
    pub user_data: Vec<u8>,    // 20 bytes
}

pub struct TD10ReportBody {
    pub tee_tcb_svn: Vec<u8>,  // 16 bytes
    pub mrseam: Vec<u8>,       // 48 bytes
    pub mrsignerseam: Vec<u8>, // 48 bytes
    pub seam_attributes: u64,
    pub td_attributes: u64,
    pub xfam: u64,
    pub mrtd: Vec<u8>,          // 48 bytes
    pub mrconfigid: Vec<u8>,    // 48 bytes
    pub mrowner: Vec<u8>,       // 48 bytes
    pub mrownerconfig: Vec<u8>, // 48 bytes
    pub rtmr0: Vec<u8>,         // 48 bytes
    pub rtmr1: Vec<u8>,         // 48 bytes
    pub rtmr2: Vec<u8>,         // 48 bytes
    pub rtmr3: Vec<u8>,         // 48 bytes
    pub report_data: Vec<u8>,   // 64 bytes
}

pub struct VerifiedQuote {
    pub quote_version: u16,
    pub tee_type: u32,
    pub tcb_status: u8,
    pub fmspc: Vec<u8>, // 6 bytes
    pub quote_body: TD10ReportBody,
}

pub struct TdxModule {
    pub mrsigner: Vec<u8>, // 48 bytes
    pub attributes: u64,
    pub attributes_mask: u64,
    pub identity_id: String, // felt252 as hex string
    pub expected_id: String, // felt252 as hex string
    pub tcb_levels: Vec<TdxModuleIdentityTcbLevel>,
}

pub struct TdxModuleIdentityTcbLevel {
    pub tcb: TdxModuleTcb,
    pub tcb_status: u8,
}

pub struct TdxModuleTcb {
    pub isvsvn: u8,
}

pub struct AttestationPubKey {
    pub x: u256,
    pub y: u256,
}

/// Secp256r1 ECDSA signature.
pub struct Signature {
    pub r: u256,
    pub s: u256,
    pub y_parity: bool,
}

pub struct ContractInputs {
    pub quote_header: QuoteHeader,
    pub quote_body: TD10ReportBody,
    pub attestation_signature: Signature,
    pub attestation_pubkey: AttestationPubKey,
    pub tdx_module: TdxModule,
    pub tcb_info_svn: Vec<u8>,
}

================
File: crates/preprocess/Cargo.toml
================
[package]
name = "preprocess"
version = "0.1.0"
edition = "2021"

[dependencies]
dcap-rs = { git = "https://github.com/automata-network/dcap-rs.git", rev = "bd86987" }
ethnum = "1.5.0"
hex = "0.4.3"
serde = "1.0.215"

================
File: dcap-cairo/src/common/bytes.cairo
================
trait BytesTrait<T> {
    fn from_le_bytes(bytes: Span<u8>) -> T;
    fn to_le_bytes(value: T) -> Span<u8>;
}

pub impl U16BytesImpl of BytesTrait<u16> {
    fn from_le_bytes(mut bytes: Span<u8>) -> u16 {
        // Ensure we have exactly 2 bytes
        assert(bytes.len() == 2, 'Invalid byte array length');

        // Get the bytes in little-endian order
        let byte0 = *bytes.pop_front().unwrap(); // Least significant byte
        let byte1 = *bytes.pop_front().unwrap(); // Most significant byte

        // Combine bytes using bitwise operations
        // byte0 is shifted 0 positions (LSB)
        // byte1 is shifted 8 positions left (MSB)
        let result = byte0.into() + (byte1.into() * 256);

        result
    }

    fn to_le_bytes(value: u16) -> Span<u8> {
        let mut bytes = ArrayTrait::new();

        // Extract least significant byte (byte0)
        // value % 256 gives us the lower 8 bits
        let byte0: u8 = (value % 256).try_into().unwrap();
        bytes.append(byte0);

        // Extract most significant byte (byte1)
        // value / 256 gives us the upper 8 bits
        let byte1: u8 = ((value / 256) % 256).try_into().unwrap();
        bytes.append(byte1);

        bytes.span()
    }
}

pub impl U32BytesImpl of BytesTrait<u32> {
    fn from_le_bytes(mut bytes: Span<u8>) -> u32 {
        assert(bytes.len() == 4, 'Invalid byte array length');

        let byte0: u32 = (*bytes.at(0)).into();
        let byte1: u32 = (*bytes.at(1)).into() * 0x100;
        let byte2: u32 = (*bytes.at(2)).into() * 0x10000;
        let byte3: u32 = (*bytes.at(3)).into() * 0x1000000;

        byte0 + byte1 + byte2 + byte3
    }

    fn to_le_bytes(value: u32) -> Span<u8> {
        let mut bytes = ArrayTrait::new();

        bytes.append((value % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x10000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x1000000) % 0x100).try_into().unwrap());

        bytes.span()
    }
}


pub impl U64BytesImpl of BytesTrait<u64> {
    fn from_le_bytes(mut bytes: Span<u8>) -> u64 {
        assert(bytes.len() == 8, 'Invalid byte array length');

        let byte0: u64 = (*bytes.at(0)).into();
        let byte1: u64 = (*bytes.at(1)).into() * 0x100;
        let byte2: u64 = (*bytes.at(2)).into() * 0x10000;
        let byte3: u64 = (*bytes.at(3)).into() * 0x1000000;
        let byte4: u64 = (*bytes.at(4)).into() * 0x100000000;
        let byte5: u64 = (*bytes.at(5)).into() * 0x10000000000;
        let byte6: u64 = (*bytes.at(6)).into() * 0x1000000000000;
        let byte7: u64 = (*bytes.at(7)).into() * 0x100000000000000;

        byte0 + byte1 + byte2 + byte3 + byte4 + byte5 + byte6 + byte7
    }

    fn to_le_bytes(value: u64) -> Span<u8> {
        let mut bytes = ArrayTrait::new();

        bytes.append((value % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x10000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x1000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x10000000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x1000000000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100000000000000) % 0x100).try_into().unwrap());

        bytes.span()
    }
}

================
File: dcap-cairo/src/common.cairo
================
pub(crate) mod bytes;

================
File: dcap-cairo/src/constants.cairo
================
pub const TDX_TEE_TYPE: u32 = 0x00000081;
pub const ECDSA_256_WITH_P256_CURVE: u16 = 2;

pub const INTEL_QE_VENDOR_ID: [u8; 16] = 
[0x93, 0x9A, 0x72, 0x33, 0xF7, 0x9C, 0x4C, 0xA9, 0x94, 0x0A, 0x0D, 0xB3, 0x95, 0x7F, 0x06, 0x07];

================
File: dcap-cairo/src/lib.cairo
================
use starknet::SyscallResultTrait;
use crate::types::{
    QuoteHeader, QuoteHeaderImpl, TdxModule, TD10ReportBody, TD10ReportBodyImpl, AttestationPubKey
};
use crate::constants::{INTEL_QE_VENDOR_ID, ECDSA_256_WITH_P256_CURVE, TDX_TEE_TYPE};
use alexandria_data_structures::span_ext::SpanTraitExt;
use alexandria_data_structures::byte_array_ext::SpanU8IntoBytearray;
use core::sha256::compute_sha256_byte_array;
use core::starknet::secp256_trait::{Signature, Secp256Trait, is_valid_signature};
use core::starknet::secp256r1::Secp256r1Point;

pub mod constants;
pub mod types;
pub mod common;

pub fn check_quote_header(header: @QuoteHeader) -> bool {
    // Version check
    if *header.version != 4 {
        return false;
    }

    // Key type check
    if *header.att_key_type != ECDSA_256_WITH_P256_CURVE {
        return false;
    }

    // TEE type check
    if *header.tee_type != TDX_TEE_TYPE {
        return false;
    }

    // Vendor ID check
    if *header.qe_vendor_id != INTEL_QE_VENDOR_ID.span() {
        return false;
    }

    return true;
}

pub fn verify_quote_signature(
    quote_header: @QuoteHeader,
    quote_body: @TD10ReportBody,
    attestation_signature: @Signature,
    attestation_pubkey: AttestationPubKey,
) -> bool {
    // Check header fields
    if !check_quote_header(quote_header) {
        return false;
    }

    // Concatenate header and quote body data for signature verification
    let mut message = (*quote_header).to_bytes().concat((*quote_body).to_bytes());

    // Hash message to SHA-256
    let message_hash: [u32; 8] = compute_sha256_byte_array(@message.span().into());

    // Convert message hash array to u256
    let message_hash_u256 = u256 {
        low: ((*message_hash.span()[0]).into() * 0x100000000_u128
            + (*message_hash.span()[1]).into())
            + ((*message_hash.span()[2]).into() * 0x100000000_u128
                + (*message_hash.span()[3]).into())
                * 0x100000000_u128,
        high: ((*message_hash.span()[4]).into() * 0x100000000_u128
            + (*message_hash.span()[5]).into())
            + ((*message_hash.span()[6]).into() * 0x100000000_u128
                + (*message_hash.span()[7]).into())
                * 0x100000000_u128,
    };

    // Create public key point from x,y coordinates
    let pubkey_point =
        match Secp256Trait::<
            Secp256r1Point
        >::secp256_ec_new_syscall(attestation_pubkey.x, attestation_pubkey.y)
            .unwrap_syscall() {
        Option::Some(point) => point,
        Option::None => { return false; }
    };

    // // Validate ECDSA signature using secp256r1
    // is_valid_signature::<
    //     Secp256r1Point
    // >(message_hash_u256, *attestation_signature.r, *attestation_signature.s, pubkey_point)

    true
}

// Verify TDX module identity matches TCB info
pub fn verify_tdx_module(quote_body: @TD10ReportBody, tdx_module: @TdxModule) -> bool {
    // Check MRSIGNER matches
    if (*quote_body.mrsignerseam) != (*tdx_module.mrsigner) {
        return false;
    }

    // Check attributes with mask
    if *quote_body.seam_attributes & *tdx_module.attributes_mask != *tdx_module.attributes {
        return false;
    }

    return true;
}

// Verify TCB level
pub fn verify_tdx_tcb(tee_tcb_svn: Span<u8>, tdx_module: @TdxModule) -> u8 {
    // Get ISV SVN and version from TEE TCB SVN
    let tdx_module_isv_svn = *tee_tcb_svn[0];
    let tdx_module_version = *tee_tcb_svn[1];

    // Special case for version 0
    if tdx_module_version == 0 {
        return 0;
    }

    // Verify module ID matches
    if *tdx_module.identity_id != *tdx_module.expected_id {
        return 7;
    }

    // Find highest TCB level where our ISV SVN meets minimum
    let mut tcb_status = 7;
    let mut tcb_levels = *tdx_module.tcb_levels;
    loop {
        match tcb_levels.pop_front() {
            Option::Some(level) => {
                if tdx_module_isv_svn >= *level.tcb.isvsvn {
                    tcb_status = *level.tcb_status;
                    break;
                }
            },
            Option::None => { break; },
        }
    };

    tcb_status
}

================
File: dcap-cairo/src/types.cairo
================
use crate::common::bytes::{U16BytesImpl, U32BytesImpl, U64BytesImpl};

#[derive(Copy, Drop, Serde)]
pub struct QuoteHeader {
    pub version: u16,
    pub att_key_type: u16,
    pub tee_type: u32,
    pub qe_svn: Span<u8>, // 2 bytes
    pub pce_svn: Span<u8>, // 2 bytes
    pub qe_vendor_id: Span<u8>, // 16 bytes
    pub user_data: Span<u8> // 20 bytes
}

#[generate_trait]
pub impl QuoteHeaderImpl of QuoteHeaderTrait {
    fn to_bytes(mut self: QuoteHeader) -> Span<u8> {
        let mut raw_bytes = ArrayTrait::new();

        raw_bytes.append_span(U16BytesImpl::to_le_bytes(self.version));
        raw_bytes.append_span(U16BytesImpl::to_le_bytes(self.att_key_type));
        raw_bytes.append_span(U32BytesImpl::to_le_bytes(self.tee_type));
        raw_bytes.append_span(self.qe_svn);
        raw_bytes.append_span(self.pce_svn);
        raw_bytes.append_span(self.qe_vendor_id);
        raw_bytes.append_span(self.user_data);

        raw_bytes.span()
    }
}

#[derive(Copy, Drop, Serde)]
pub struct TD10ReportBody {
    pub tee_tcb_svn: Span<u8>, // 16 bytes
    pub mrseam: Span<u8>, // 48 bytes
    pub mrsignerseam: Span<u8>, // 48 bytes
    pub seam_attributes: u64,
    pub td_attributes: u64,
    pub xfam: u64,
    pub mrtd: Span<u8>, // 48 bytes
    pub mrconfigid: Span<u8>, // 48 bytes
    pub mrowner: Span<u8>, // 48 bytes
    pub mrownerconfig: Span<u8>, // 48 bytes
    pub rtmr0: Span<u8>, // 48 bytes
    pub rtmr1: Span<u8>, // 48 bytes
    pub rtmr2: Span<u8>, // 48 bytes
    pub rtmr3: Span<u8>, // 48 bytes
    pub report_data: Span<u8>, // 64 bytes
}

#[generate_trait]
pub impl TD10ReportBodyImpl of TD10ReportBodyTrait {
    fn to_bytes(mut self: TD10ReportBody) -> Span<u8> {
        let mut raw_bytes = ArrayTrait::new();

        raw_bytes.append_span(self.tee_tcb_svn);
        raw_bytes.append_span(self.mrseam);
        raw_bytes.append_span(self.mrsignerseam);
        raw_bytes.append_span(U64BytesImpl::to_le_bytes(self.seam_attributes));
        raw_bytes.append_span(U64BytesImpl::to_le_bytes(self.td_attributes));
        raw_bytes.append_span(U64BytesImpl::to_le_bytes(self.xfam));
        raw_bytes.append_span(self.mrtd);
        raw_bytes.append_span(self.mrconfigid);
        raw_bytes.append_span(self.mrowner);
        raw_bytes.append_span(self.mrownerconfig);
        raw_bytes.append_span(self.rtmr0);
        raw_bytes.append_span(self.rtmr1);
        raw_bytes.append_span(self.rtmr2);
        raw_bytes.append_span(self.rtmr3);
        raw_bytes.append_span(self.report_data);

        raw_bytes.span()
    }
}


#[derive(Copy, Drop, Serde)]
pub struct VerifiedQuote {
    pub quote_version: u16,
    pub tee_type: u32,
    pub tcb_status: u8,
    pub fmspc: Span<u8>, // 6 bytes
    pub quote_body: TD10ReportBody
}

// TDX Module Fields parsed from TCBInfo
#[derive(Drop, Serde)]
pub struct TdxModule {
    pub mrsigner: Span<u8>, // 48 bytes
    pub attributes: u64,
    pub attributes_mask: u64,
    pub identity_id: felt252,
    pub expected_id: felt252,
    pub tcb_levels: Span<TdxModuleIdentityTcbLevel>
}

#[derive(Drop, Copy, Serde)]
pub struct TdxModuleIdentityTcbLevel {
    pub tcb: TdxModuleTcb,
    pub tcb_status: u8,
}

#[derive(Drop, Copy, Serde)]
pub struct TdxModuleTcb {
    pub isvsvn: u8
}

#[derive(Drop, Copy, Serde)]
pub struct AttestationPubKey {
    pub x: u256,
    pub y: u256
}

const TCB_STATUS_OK: u8 = 0;
const TCB_STATUS_SW_HARDENING_NEEDED: u8 = 1;
const TCB_STATUS_CONFIG_NEEDED: u8 = 2;
const TCB_STATUS_CONFIG_AND_SW_HARDENING_NEEDED: u8 = 3;
const TCB_STATUS_OUT_OF_DATE: u8 = 4;
const TCB_STATUS_OUT_OF_DATE_CONFIG_NEEDED: u8 = 5;
const TCB_STATUS_REVOKED: u8 = 6;
const TCB_STATUS_UNRECOGNIZED: u8 = 7;

================
File: dcap-cairo/Scarb.toml
================
[package]
name = "dcap_cairo"
version = "0.1.0"
edition = "2024_07"


[dependencies]
alexandria_data_structures = {git = "https://github.com/keep-starknet-strange/alexandria.git", rev = "95d98a5"}

[dev-dependencies]
cairo_test = "2.8.4"

================
File: scripts/gen_test_data/src/main.rs
================
use dcap_rs::types::collaterals::IntelCollateral;
use dcap_rs::types::quotes::version_4::QuoteV4;
use preprocess::parser::prepare_cairo_inputs;

use std::fs::File;
use std::io::Write;

pub fn main() {
    // Load TDX quote from binary data file
    let quote = QuoteV4::from_bytes(include_bytes!("../data/quote_tdx_00806f050000.dat"));

    // Initialize Intel collateral structure and load verification data
    let mut collaterals = IntelCollateral::new();
    collaterals.set_tcbinfo_bytes(include_bytes!("../data/tcbinfov3_00806f050000.json"));
    collaterals.set_qeidentity_bytes(include_bytes!("../data/qeidentityv2_apiv4.json"));
    collaterals.set_intel_root_ca_der(include_bytes!(
        "../data/Intel_SGX_Provisioning_Certification_RootCA.cer"
    ));
    collaterals.set_sgx_tcb_signing_pem(include_bytes!("../data/signing_cert.pem"));
    collaterals.set_sgx_intel_root_ca_crl_der(include_bytes!("../data/intel_root_ca_crl.der"));
    collaterals.set_sgx_platform_crl_der(include_bytes!("../data/pck_platform_crl.der"));
    collaterals.set_sgx_processor_crl_der(include_bytes!("../data/pck_processor_crl.der"));

    // Prepare inputs for Cairo contract
    let inputs = prepare_cairo_inputs(&quote, &collaterals);

    // Generate Cairo code for constructor arguments
    let cairo_code = format!(
        "
            let quote_header = QuoteHeader {{
                version: {},
                att_key_type: {},
                tee_type: {},
                qe_svn: [{}].span(),
                pce_svn: [{}].span(),
                qe_vendor_id: [{}].span(),
                user_data: [{}].span()
            }};
            let quote_body = TD10ReportBody {{
                tee_tcb_svn: [{}].span(),
                mrseam: [{}].span(),
                mrsignerseam: [{}].span(),
                seam_attributes: {},
                td_attributes: {},
                xfam: {},
                mrtd: [{}].span(),
                mrconfigid: [{}].span(),
                mrowner: [{}].span(),
                mrownerconfig: [{}].span(),
                rtmr0: [{}].span(),
                rtmr1: [{}].span(),
                rtmr2: [{}].span(),
                rtmr3: [{}].span(),
                report_data: [{}].span(),
            }};
            let attestation_signature = Signature {{ 
                r: {}, 
                s: {}, 
                y_parity: {} 
            }};
            let attestation_pubkey = AttestationPubKey {{ 
                x: {}, 
                y: {} 
            }};
            let tdx_module = TdxModule {{
                mrsigner: [{}].span(),
                attributes: {},
                attributes_mask: {},
                identity_id: {},
                expected_id: {},
                tcb_levels: {}
            }};
            let tcb_info_svn = [{}].span();
        ",
        // Quote Header
        inputs.quote_header.version,
        inputs.quote_header.att_key_type,
        inputs.quote_header.tee_type,
        inputs.quote_header.qe_svn.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_header.pce_svn.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_header.qe_vendor_id.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_header.user_data.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        // TD10 Report Body
        inputs.quote_body.tee_tcb_svn.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.mrseam.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.mrsignerseam.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.seam_attributes,
        inputs.quote_body.td_attributes,
        inputs.quote_body.xfam,
        inputs.quote_body.mrtd.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.mrconfigid.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.mrowner.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.mrownerconfig.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.rtmr0.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.rtmr1.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.rtmr2.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.rtmr3.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.quote_body.report_data.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        // Signature
        inputs.attestation_signature.r,
        inputs.attestation_signature.s,
        inputs.attestation_signature.y_parity,
        // Public Key
        inputs.attestation_pubkey.x,
        inputs.attestation_pubkey.y,
        // TDX Module
        inputs.tdx_module.mrsigner.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", "),
        inputs.tdx_module.attributes,
        inputs.tdx_module.attributes_mask,
        inputs.tdx_module.identity_id,
        inputs.tdx_module.expected_id,
        format!("[{}].span()", 
            inputs.tdx_module.tcb_levels.iter()
                .map(|level| format!("TdxModuleIdentityTcbLevel {{ tcb: TdxModuleTcb {{ isvsvn: {} }}, tcb_status: {} }}", 
                    level.tcb.isvsvn, level.tcb_status))
                .collect::<Vec<_>>()
                .join(", ")
        ),
        // TCB Info SVN
        inputs.tcb_info_svn.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", ")
    );

    let path = "test_data.txt";
    let mut file = File::create(path).expect("Could not create file");

    // Write the cairo code to the file
    file.write_all(cairo_code.as_bytes())
        .expect("Could not write to file");
}

================
File: scripts/gen_test_data/Cargo.toml
================
[package]
name = "gen_test_data"
version = "0.1.0"
edition = "2021"

[dependencies]
dcap-rs = { git = "https://github.com/automata-network/dcap-rs.git", rev = "bd86987" }
preprocess = { path = "../../crates/preprocess" }

================
File: .gitignore
================
**/target
**/.snfoundry_cache/

================
File: .tool-versions
================
scarb 2.8.4

================
File: README.md
================
# TDX Cairo Verifier [WIP]

A quote verifier for [Intel's TDX](https://www.intel.com/content/www/us/en/developer/tools/trust-domain-extensions/overview.html), implemented in Cairo. 
It enables trust-minimized validation of TEE quotes without relying on [attestation authority services](https://docs.trustauthority.intel.com/main/articles/introduction.html).

> ⚠️ SECURITY WARNING: This is experimental software and under development. Do not use in production.
