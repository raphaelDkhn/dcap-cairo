This file is a merged representation of the entire codebase of my TDX Cairo Verifier, combining all repository files into a single document.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
contract/
  src/
    lib.cairo
  tests/
    test_contract.cairo
  Scarb.toml
crates/
  macros/
    Cargo.toml
    Scarb.toml
  preprocess/
    src/
      lib.rs
      parser.rs
      types.rs
    Cargo.toml
data/
  Intel_SGX_Provisioning_Certification_RootCA.cer
  intel_root_ca_crl.der
  pck_platform_crl.der
  pck_processor_crl.der
  qeidentityv2_apiv4.json
  quote_tdx_00806f050000.dat
  signing_cert.pem
  tcbinfov3_00806f050000.json
dcap-cairo/
  src/
    common/
      bytes.cairo
    common.cairo
    constants.cairo
    lib.cairo
    types.cairo
  Scarb.toml
.gitignore
.tool-versions
README.md

================================================================
Repository Files
================================================================

================
File: contract/src/lib.cairo
================
use dcap_cairo::types::{QuoteHeader, TD10ReportBody, AttestationPubKey, TdxModule};
use core::starknet::secp256_trait::Signature;

#[starknet::interface]
pub trait ITdxVerifier<TContractState> {
    fn verify_tdx(
        self: @TContractState,
        quote_header: QuoteHeader,
        quote_body: TD10ReportBody,
        attestation_signature: Signature,
        attestation_pubkey: AttestationPubKey,
        tdx_module: TdxModule,
        tcb_info_svn: Span<u8>,
    ) -> bool;
}

#[starknet::contract]
mod TdxVerifier {
    use super::{QuoteHeader, TD10ReportBody, Signature, TdxModule, AttestationPubKey};
    use dcap_cairo::{verify_quote_signature, verify_tdx_module, verify_tdx_tcb};

    #[storage]
    struct Storage {}


    #[abi(embed_v0)]
    impl TdxVerifierImpl of super::ITdxVerifier<ContractState> {
        fn verify_tdx(
            self: @ContractState,
            quote_header: QuoteHeader,
            quote_body: TD10ReportBody,
            attestation_signature: Signature,
            attestation_pubkey: AttestationPubKey,
            tdx_module: TdxModule,
            tcb_info_svn: Span<u8>,
        ) -> bool {
            // Verify quote signature
            if !verify_quote_signature(
                @quote_header, @quote_body, @attestation_signature, attestation_pubkey,
            ) {
                return false;
            }

            // Verify TDX module identity
            if !verify_tdx_module(@quote_body, @tdx_module) {
                return false;
            }

            // Get TCB status from TDX module verification
            let tcb_status = verify_tdx_tcb(quote_body.tee_tcb_svn, @tdx_module);
            if tcb_status != 0 {
                return false;
            }

            true
        }
    }
}

================
File: contract/tests/test_contract.cairo
================
use starknet::ContractAddress;

use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};

use tdx_verifier::ITdxVerifierDispatcher;
use tdx_verifier::ITdxVerifierDispatcherTrait;

fn deploy_contract(name: ByteArray) -> ContractAddress {
    let contract = declare(name).unwrap().contract_class();
    let (contract_address, _) = contract.deploy(@ArrayTrait::new()).unwrap();
    contract_address
}

#[test]
fn test_verify_tdx() {
    let contract_address = deploy_contract("TdxVerifier");

    let dispatcher = ITdxVerifierDispatcher { contract_address };

    // let is_valid = dispatcher.verify_tdx();
    // assert(is_valid == true, 'quote not valid');
}

================
File: contract/Scarb.toml
================
[package]
name = "tdx_verifier"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.8.4"
dcap_cairo = {path = "../dcap-cairo"}

[dev-dependencies]
snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry", tag = "v0.33.0" }
assert_macros = "2.8.4"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# Visit https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html for more information

# [tool.snforge]                                             # Define `snforge` tool section
# exit_first = true                                          # Stop tests execution immediately upon the first failure
# fuzzer_runs = 1234                                         # Number of runs of the random fuzzer
# fuzzer_seed = 1111                                         # Seed for the random fuzzer

# [[tool.snforge.fork]]                                      # Used for fork testing
# name = "SOME_NAME"                                         # Fork name
# url = "http://your.rpc.url"                                # Url of the RPC provider
# block_id.tag = "latest"                                    # Block to fork from (block tag)

# [[tool.snforge.fork]]
# name = "SOME_SECOND_NAME"
# url = "http://your.second.rpc.url"                         
# block_id.number = "123"                                    # Block to fork from (block number)

# [[tool.snforge.fork]]
# name = "SOME_THIRD_NAME"
# url = "http://your.third.rpc.url"
# block_id.hash = "0x123"                                    # Block to fork from (block hash)

# [profile.dev.cairo]                                        # Configure Cairo compiler
# unstable-add-statements-code-locations-debug-info = true   # Should be used if you want to use coverage
# unstable-add-statements-functions-debug-info = true        # Should be used if you want to use coverage/profiler
# inlining-strategy = "avoid"                                # Should be used if you want to use coverage

# [features]                                                 # Used for conditional compilation
# enable_for_tests = []                                      # Feature name and list of other features that should be enabled with it

================
File: crates/macros/Cargo.toml
================
[package]
name = "tdx_macros"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
bigdecimal = "0.4.5"
cairo-lang-macro = "0.1"
cairo-lang-parser = "2.7.0"
cairo-lang-syntax = "2.7.0"

================
File: crates/macros/Scarb.toml
================
[package]
name = "tdx_macros"
version = "0.1.0"
edition = "2024_07"

[cairo-plugin]

[dev-dependencies]
cairo_test = "2.8.4"

================
File: crates/preprocess/src/lib.rs
================
pub mod types;
pub mod parser;

================
File: crates/preprocess/src/parser.rs
================
use dcap_rs::types::{
    collaterals::IntelCollateral,
    quotes::{body::QuoteBody, version_4::QuoteV4},
};

use crate::types::{
    AttestationPubKey, ContractInputs, QuoteHeader, Signature, TD10ReportBody, TdxModule,
    TdxModuleIdentityTcbLevel, TdxModuleTcb,
};

pub fn prepare_cairo_inputs(quote: &QuoteV4, collaterals: &IntelCollateral) -> ContractInputs {
    // Extract quote header
    let cairo_header = QuoteHeader {
        version: quote.header.version,
        att_key_type: quote.header.att_key_type,
        tee_type: quote.header.tee_type,
        qe_svn: quote.header.qe_svn.to_vec(),
        pce_svn: quote.header.pce_svn.to_vec(),
        qe_vendor_id: quote.header.qe_vendor_id.to_vec(),
        user_data: quote.header.user_data.to_vec(),
    };

    // Extract TD10 report body
    let td10_body = if let QuoteBody::TD10QuoteBody(body) = quote.quote_body {
        TD10ReportBody {
            tee_tcb_svn: body.tee_tcb_svn.to_vec(),
            mrseam: body.mrseam.to_vec(),
            mrsignerseam: body.mrsignerseam.to_vec(),
            seam_attributes: body.seam_attributes,
            td_attributes: body.td_attributes,
            xfam: body.xfam,
            mrtd: body.mrtd.to_vec(),
            mrconfigid: body.mrconfigid.to_vec(),
            mrowner: body.mrowner.to_vec(),
            mrownerconfig: body.mrownerconfig.to_vec(),
            rtmr0: body.rtmr0.to_vec(),
            rtmr1: body.rtmr1.to_vec(),
            rtmr2: body.rtmr2.to_vec(),
            rtmr3: body.rtmr3.to_vec(),
            report_data: body.report_data.to_vec(),
        }
    } else {
        panic!("Not a TD10 quote body");
    };

    // Extract ECDSA signature
    let signature = {
        let sig = &quote.signature.quote_signature;
        let (r, s) = sig.split_at(32);

        // Convert both parts of the signature
        let r_u128 = slice_to_u128(r).expect("Invalid R component");
        let s_u128 = slice_to_u128(s).expect("Invalid S component");

        // Create the signature struct
        Signature {
            r: r_u128,
            s: s_u128,
            y_parity: false,
        }
    };

    // Get attestation public key
    let pubkey = {
        let key = &quote.signature.ecdsa_attestation_key;
        let (x, y) = key.split_at(32);
        AttestationPubKey {
            x: slice_to_u128(x).expect("Invalid X component"),
            y: slice_to_u128(y).expect("Invalid X component"),
        }
    };

    // Extract TDX module info from TCBInfo
    let tcbinfo_v3 = collaterals.get_tcbinfov3();
    let tdx_module = if let Some(module) = &tcbinfo_v3.tcb_info.tdx_module {
        // Get version from quote's TEE TCB SVN
        let tdx_module_version = if let QuoteBody::TD10QuoteBody(ref body) = quote.quote_body {
            body.tee_tcb_svn[1]
        } else {
            panic!("Not a TD10 quote body");
        };

        // Pre-format the expected module ID
        let expected_id = format!("TDX_{:02x}", tdx_module_version);

        // Collect TCB levels and get module ID for the matching version
        let mut levels = Vec::new();
        let mut identity_id = String::new();

        if let Some(identities) = &tcbinfo_v3.tcb_info.tdx_module_identities {
            for identity in identities {
                if identity.id == expected_id {
                    identity_id = identity.id.clone(); // Get the ID from matching identity
                    for level in &identity.tcb_levels {
                        levels.push(TdxModuleIdentityTcbLevel {
                            tcb: TdxModuleTcb {
                                isvsvn: level.tcb.isvsvn,
                            },
                            tcb_status: match level.tcb_status.as_str() {
                                "UpToDate" => 0,
                                "SWHardeningNeeded" => 1,
                                "ConfigurationNeeded" => 2,
                                "ConfigurationAndSWHardeningNeeded" => 3,
                                "OutOfDate" => 4,
                                "OutOfDateConfigurationNeeded" => 5,
                                "Revoked" => 6,
                                _ => 7, // UNRECOGNIZED
                            },
                        });
                    }
                }
            }
        }
        levels.sort_by(|a, b| b.tcb.isvsvn.cmp(&a.tcb.isvsvn));

        let mrsigner = hex::decode(&module.mrsigner).unwrap();
        let mut mrsigner_bytes = [0u8; 48];
        mrsigner_bytes.copy_from_slice(&mrsigner);

        TdxModule {
            mrsigner: mrsigner_bytes.to_vec(),
            attributes: u64::from_str_radix(&module.attributes, 16).unwrap(),
            attributes_mask: u64::from_str_radix(&module.attributes_mask, 16).unwrap(),
            identity_id, // Get ID from matching identity
            expected_id, // Expected ID based on version
            tcb_levels: levels,
        }
    } else {
        panic!("No TDX module in TCBInfo");
    };

    // Get TCB SVN values for comparison
    let tcb_info_svn = if let Some(tcb_level) = tcbinfo_v3.tcb_info.tcb_levels.first() {
        if let Some(tdx_components) = &tcb_level.tcb.tdxtcbcomponents {
            tdx_components.iter().map(|comp| comp.svn as u8).collect()
        } else {
            Vec::new()
        }
    } else {
        panic!("No TCB levels found");
    };

    ContractInputs {
        quote_header: cairo_header,
        quote_body: td10_body,
        attestation_signature: signature,
        attestation_pubkey: pubkey,
        tdx_module,
        tcb_info_svn,
    }
}

// Helper function to convert a slice to u128
fn slice_to_u128(slice: &[u8]) -> Result<u128, &'static str> {
    if slice.len() == 16 {
        Ok(u128::from_le_bytes(
            slice.try_into().expect("slice with incorrect length"),
        ))
    } else {
        Err("Incorrect number of bytes")
    }
}

================
File: crates/preprocess/src/types.rs
================
pub struct QuoteHeader {
    pub version: u16,
    pub att_key_type: u16,
    pub tee_type: u32,
    pub qe_svn: Vec<u8>,       // 2 bytes
    pub pce_svn: Vec<u8>,      // 2 bytes
    pub qe_vendor_id: Vec<u8>, // 16 bytes
    pub user_data: Vec<u8>,    // 20 bytes
}

pub struct TD10ReportBody {
    pub tee_tcb_svn: Vec<u8>,  // 16 bytes
    pub mrseam: Vec<u8>,       // 48 bytes
    pub mrsignerseam: Vec<u8>, // 48 bytes
    pub seam_attributes: u64,
    pub td_attributes: u64,
    pub xfam: u64,
    pub mrtd: Vec<u8>,          // 48 bytes
    pub mrconfigid: Vec<u8>,    // 48 bytes
    pub mrowner: Vec<u8>,       // 48 bytes
    pub mrownerconfig: Vec<u8>, // 48 bytes
    pub rtmr0: Vec<u8>,         // 48 bytes
    pub rtmr1: Vec<u8>,         // 48 bytes
    pub rtmr2: Vec<u8>,         // 48 bytes
    pub rtmr3: Vec<u8>,         // 48 bytes
    pub report_data: Vec<u8>,   // 64 bytes
}

pub struct VerifiedQuote {
    pub quote_version: u16,
    pub tee_type: u32,
    pub tcb_status: u8,
    pub fmspc: Vec<u8>, // 6 bytes
    pub quote_body: TD10ReportBody,
}

pub struct TdxModule {
    pub mrsigner: Vec<u8>, // 48 bytes
    pub attributes: u64,
    pub attributes_mask: u64,
    pub identity_id: String, // felt252 as hex string
    pub expected_id: String, // felt252 as hex string
    pub tcb_levels: Vec<TdxModuleIdentityTcbLevel>,
}

pub struct TdxModuleIdentityTcbLevel {
    pub tcb: TdxModuleTcb,
    pub tcb_status: u8,
}

pub struct TdxModuleTcb {
    pub isvsvn: u8,
}

pub struct AttestationPubKey {
    pub x: u128,
    pub y: u128,
}

/// Secp256r1 ECDSA signature.
pub struct Signature {
    pub r: u128,
    pub s: u128,
    pub y_parity: bool,
}

pub struct ContractInputs {
    pub quote_header: QuoteHeader,
    pub quote_body: TD10ReportBody,
    pub attestation_signature: Signature,
    pub attestation_pubkey: AttestationPubKey,
    pub tdx_module: TdxModule,
    pub tcb_info_svn: Vec<u8>,
}

================
File: crates/preprocess/Cargo.toml
================
[package]
name = "preprocess"
version = "0.1.0"
edition = "2021"

[dependencies]
dcap-rs = { git = "https://github.com/automata-network/dcap-rs.git", rev = "bd86987" }
hex = "0.4.3"
serde = "1.0.215"
cairo-vm = { git = "https://github.com/lambdaclass/cairo-vm", rev = "0d86936", features = [
    "std",
    "cairo-1-hints",
] }

================
File: dcap-cairo/src/common/bytes.cairo
================
trait BytesTrait<T> {
    fn from_le_bytes(bytes: Span<u8>) -> T;
    fn to_le_bytes(value: T) -> Span<u8>;
}

pub impl U16BytesImpl of BytesTrait<u16> {
    fn from_le_bytes(mut bytes: Span<u8>) -> u16 {
        // Ensure we have exactly 2 bytes
        assert(bytes.len() == 2, 'Invalid byte array length');

        // Get the bytes in little-endian order
        let byte0 = *bytes.pop_front().unwrap(); // Least significant byte
        let byte1 = *bytes.pop_front().unwrap(); // Most significant byte

        // Combine bytes using bitwise operations
        // byte0 is shifted 0 positions (LSB)
        // byte1 is shifted 8 positions left (MSB)
        let result = byte0.into() + (byte1.into() * 256);

        result
    }

    fn to_le_bytes(value: u16) -> Span<u8> {
        let mut bytes = ArrayTrait::new();

        // Extract least significant byte (byte0)
        // value % 256 gives us the lower 8 bits
        let byte0: u8 = (value % 256).try_into().unwrap();
        bytes.append(byte0);

        // Extract most significant byte (byte1)
        // value / 256 gives us the upper 8 bits
        let byte1: u8 = ((value / 256) % 256).try_into().unwrap();
        bytes.append(byte1);

        bytes.span()
    }
}

pub impl U32BytesImpl of BytesTrait<u32> {
    fn from_le_bytes(mut bytes: Span<u8>) -> u32 {
        assert(bytes.len() == 4, 'Invalid byte array length');

        let byte0: u32 = (*bytes.at(0)).into();
        let byte1: u32 = (*bytes.at(1)).into() * 0x100;
        let byte2: u32 = (*bytes.at(2)).into() * 0x10000;
        let byte3: u32 = (*bytes.at(3)).into() * 0x1000000;

        byte0 + byte1 + byte2 + byte3
    }

    fn to_le_bytes(value: u32) -> Span<u8> {
        let mut bytes = ArrayTrait::new();

        bytes.append((value % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x10000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x1000000) % 0x100).try_into().unwrap());

        bytes.span()
    }
}


pub impl U64BytesImpl of BytesTrait<u64> {
    fn from_le_bytes(mut bytes: Span<u8>) -> u64 {
        assert(bytes.len() == 8, 'Invalid byte array length');

        let byte0: u64 = (*bytes.at(0)).into();
        let byte1: u64 = (*bytes.at(1)).into() * 0x100;
        let byte2: u64 = (*bytes.at(2)).into() * 0x10000;
        let byte3: u64 = (*bytes.at(3)).into() * 0x1000000;
        let byte4: u64 = (*bytes.at(4)).into() * 0x100000000;
        let byte5: u64 = (*bytes.at(5)).into() * 0x10000000000;
        let byte6: u64 = (*bytes.at(6)).into() * 0x1000000000000;
        let byte7: u64 = (*bytes.at(7)).into() * 0x100000000000000;

        byte0 + byte1 + byte2 + byte3 + byte4 + byte5 + byte6 + byte7
    }

    fn to_le_bytes(value: u64) -> Span<u8> {
        let mut bytes = ArrayTrait::new();

        bytes.append((value % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x10000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x1000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x10000000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x1000000000000) % 0x100).try_into().unwrap());
        bytes.append(((value / 0x100000000000000) % 0x100).try_into().unwrap());

        bytes.span()
    }
}

================
File: dcap-cairo/src/common.cairo
================
pub(crate) mod bytes;

================
File: dcap-cairo/src/constants.cairo
================
pub const TDX_TEE_TYPE: u32 = 0x00000081;
pub const ECDSA_256_WITH_P256_CURVE: u16 = 2;

pub const INTEL_QE_VENDOR_ID: [u8; 16] = 
[0x93, 0x9A, 0x72, 0x33, 0xF7, 0x9C, 0x4C, 0xA9, 0x94, 0x0A, 0x0D, 0xB3, 0x95, 0x7F, 0x06, 0x07];

================
File: dcap-cairo/src/lib.cairo
================
use starknet::SyscallResultTrait;
use crate::types::{
    QuoteHeader, QuoteHeaderImpl, TdxModule, TD10ReportBody, TD10ReportBodyImpl, AttestationPubKey
};
use crate::constants::{INTEL_QE_VENDOR_ID, ECDSA_256_WITH_P256_CURVE, TDX_TEE_TYPE};
use alexandria_data_structures::span_ext::SpanTraitExt;
use alexandria_data_structures::byte_array_ext::SpanU8IntoBytearray;
use core::sha256::compute_sha256_byte_array;
use core::starknet::secp256_trait::{Signature, Secp256Trait, is_valid_signature};
use core::starknet::secp256r1::Secp256r1Point;

pub mod constants;
pub mod types;
pub mod common;

pub fn check_quote_header(header: @QuoteHeader) -> bool {
    // Version check
    if *header.version != 4 {
        return false;
    }

    // Key type check
    if *header.att_key_type != ECDSA_256_WITH_P256_CURVE {
        return false;
    }

    // TEE type check
    if *header.tee_type != TDX_TEE_TYPE {
        return false;
    }

    // Vendor ID check
    if *header.qe_vendor_id != INTEL_QE_VENDOR_ID.span() {
        return false;
    }

    return true;
}

pub fn verify_quote_signature(
    quote_header: @QuoteHeader,
    quote_body: @TD10ReportBody,
    attestation_signature: @Signature,
    attestation_pubkey: AttestationPubKey,
) -> bool {
    // Check header fields
    if !check_quote_header(quote_header) {
        return false;
    }

    // Concatenate header and quote body data for signature verification
    let mut message = (*quote_header).to_bytes().concat((*quote_body).to_bytes());

    // Hash message to SHA-256
    let message_hash: [u32; 8] = compute_sha256_byte_array(@message.span().into());

    // Convert message hash array to u256
    let message_hash_u256 = u256 {
        low: ((*message_hash.span()[0]).into() * 0x100000000_u128
            + (*message_hash.span()[1]).into())
            + ((*message_hash.span()[2]).into() * 0x100000000_u128
                + (*message_hash.span()[3]).into())
                * 0x100000000_u128,
        high: ((*message_hash.span()[4]).into() * 0x100000000_u128
            + (*message_hash.span()[5]).into())
            + ((*message_hash.span()[6]).into() * 0x100000000_u128
                + (*message_hash.span()[7]).into())
                * 0x100000000_u128,
    };

    // Create public key point from x,y coordinates
    let pubkey_point =
        match Secp256Trait::<
            Secp256r1Point
        >::secp256_ec_new_syscall(attestation_pubkey.x, attestation_pubkey.y)
            .unwrap_syscall() {
        Option::Some(point) => point,
        Option::None => { return false; }
    };

    // Validate ECDSA signature using secp256r1
    is_valid_signature::<
        Secp256r1Point
    >(message_hash_u256, *attestation_signature.r, *attestation_signature.s, pubkey_point)
}

// Verify TDX module identity matches TCB info
pub fn verify_tdx_module(quote_body: @TD10ReportBody, tdx_module: @TdxModule) -> bool {
    // Check MRSIGNER matches
    if (*quote_body.mrsignerseam) != (*tdx_module.mrsigner) {
        return false;
    }

    // Check attributes with mask
    if *quote_body.seam_attributes & *tdx_module.attributes_mask != *tdx_module.attributes {
        return false;
    }

    return true;
}

// Verify TCB level
pub fn verify_tdx_tcb(tee_tcb_svn: Span<u8>, tdx_module: @TdxModule) -> u8 {
    // Get ISV SVN and version from TEE TCB SVN
    let tdx_module_isv_svn = *tee_tcb_svn[0];
    let tdx_module_version = *tee_tcb_svn[1];

    // Special case for version 0
    if tdx_module_version == 0 {
        return 0;
    }

    // Verify module ID matches
    if *tdx_module.identity_id != *tdx_module.expected_id {
        return 7;
    }

    // Find highest TCB level where our ISV SVN meets minimum
    let mut tcb_status = 7;
    let mut tcb_levels = *tdx_module.tcb_levels;
    loop {
        match tcb_levels.pop_front() {
            Option::Some(level) => {
                if tdx_module_isv_svn >= *level.tcb.isvsvn {
                    tcb_status = *level.tcb_status;
                    break;
                }
            },
            Option::None => { break; },
        }
    };

    tcb_status
}

================
File: dcap-cairo/src/types.cairo
================
use crate::common::bytes::{U16BytesImpl, U32BytesImpl, U64BytesImpl};

#[derive(Copy, Drop, Serde)]
pub struct QuoteHeader {
    pub version: u16,
    pub att_key_type: u16,
    pub tee_type: u32,
    pub qe_svn: Span<u8>, // 2 bytes
    pub pce_svn: Span<u8>, // 2 bytes
    pub qe_vendor_id: Span<u8>, // 16 bytes
    pub user_data: Span<u8> // 20 bytes
}

#[generate_trait]
pub impl QuoteHeaderImpl of QuoteHeaderTrait {
    fn to_bytes(mut self: QuoteHeader) -> Span<u8> {
        let mut raw_bytes = ArrayTrait::new();

        raw_bytes.append_span(U16BytesImpl::to_le_bytes(self.version));
        raw_bytes.append_span(U16BytesImpl::to_le_bytes(self.att_key_type));
        raw_bytes.append_span(U32BytesImpl::to_le_bytes(self.tee_type));
        raw_bytes.append_span(self.qe_svn);
        raw_bytes.append_span(self.pce_svn);
        raw_bytes.append_span(self.qe_vendor_id);
        raw_bytes.append_span(self.user_data);

        raw_bytes.span()
    }
}

#[derive(Copy, Drop, Serde)]
pub struct TD10ReportBody {
    pub tee_tcb_svn: Span<u8>, // 16 bytes
    pub mrseam: Span<u8>, // 48 bytes
    pub mrsignerseam: Span<u8>, // 48 bytes
    pub seam_attributes: u64,
    pub td_attributes: u64,
    pub xfam: u64,
    pub mrtd: Span<u8>, // 48 bytes
    pub mrconfigid: Span<u8>, // 48 bytes
    pub mrowner: Span<u8>, // 48 bytes
    pub mrownerconfig: Span<u8>, // 48 bytes
    pub rtmr0: Span<u8>, // 48 bytes
    pub rtmr1: Span<u8>, // 48 bytes
    pub rtmr2: Span<u8>, // 48 bytes
    pub rtmr3: Span<u8>, // 48 bytes
    pub report_data: Span<u8>, // 64 bytes
}

#[generate_trait]
pub impl TD10ReportBodyImpl of TD10ReportBodyTrait {
    fn to_bytes(mut self: TD10ReportBody) -> Span<u8> {
        let mut raw_bytes = ArrayTrait::new();

        raw_bytes.append_span(self.tee_tcb_svn);
        raw_bytes.append_span(self.mrseam);
        raw_bytes.append_span(self.mrsignerseam);
        raw_bytes.append_span(U64BytesImpl::to_le_bytes(self.seam_attributes));
        raw_bytes.append_span(U64BytesImpl::to_le_bytes(self.td_attributes));
        raw_bytes.append_span(U64BytesImpl::to_le_bytes(self.xfam));
        raw_bytes.append_span(self.mrtd);
        raw_bytes.append_span(self.mrconfigid);
        raw_bytes.append_span(self.mrowner);
        raw_bytes.append_span(self.mrownerconfig);
        raw_bytes.append_span(self.rtmr0);
        raw_bytes.append_span(self.rtmr1);
        raw_bytes.append_span(self.rtmr2);
        raw_bytes.append_span(self.rtmr3);
        raw_bytes.append_span(self.report_data);

        raw_bytes.span()
    }
}


#[derive(Copy, Drop, Serde)]
pub struct VerifiedQuote {
    pub quote_version: u16,
    pub tee_type: u32,
    pub tcb_status: u8,
    pub fmspc: Span<u8>, // 6 bytes
    pub quote_body: TD10ReportBody
}

// TDX Module Fields parsed from TCBInfo
#[derive(Drop, Serde)]
pub struct TdxModule {
    pub mrsigner: Span<u8>, // 48 bytes
    pub attributes: u64,
    pub attributes_mask: u64,
    pub identity_id: felt252,
    pub expected_id: felt252,
    pub tcb_levels: Span<TdxModuleIdentityTcbLevel>
}

#[derive(Drop, Copy, Serde)]
pub struct TdxModuleIdentityTcbLevel {
    pub tcb: TdxModuleTcb,
    pub tcb_status: u8,
}

#[derive(Drop, Copy, Serde)]
pub struct TdxModuleTcb {
    pub isvsvn: u8
}

#[derive(Drop, Copy, Serde)]
pub struct AttestationPubKey {
    pub x: u256,
    pub y: u256
}

const TCB_STATUS_OK: u8 = 0;
const TCB_STATUS_SW_HARDENING_NEEDED: u8 = 1;
const TCB_STATUS_CONFIG_NEEDED: u8 = 2;
const TCB_STATUS_CONFIG_AND_SW_HARDENING_NEEDED: u8 = 3;
const TCB_STATUS_OUT_OF_DATE: u8 = 4;
const TCB_STATUS_OUT_OF_DATE_CONFIG_NEEDED: u8 = 5;
const TCB_STATUS_REVOKED: u8 = 6;
const TCB_STATUS_UNRECOGNIZED: u8 = 7;

================
File: dcap-cairo/Scarb.toml
================
[package]
name = "dcap_cairo"
version = "0.1.0"
edition = "2024_07"


[dependencies]
alexandria_data_structures = {git = "https://github.com/keep-starknet-strange/alexandria.git", rev = "95d98a5"}
tdx_macros = { path = "../crates/macros" }

[dev-dependencies]
cairo_test = "2.8.4"

[cairo]
enable-gas = false

================
File: .gitignore
================
**/target
**/.snfoundry_cache/

================
File: .tool-versions
================
scarb 2.8.4

================
File: README.md
================
# TDX Cairo Verifier [WIP]

A quote verifier for [Intel's TDX](https://www.intel.com/content/www/us/en/developer/tools/trust-domain-extensions/overview.html), implemented in Cairo. 
It enables trust-minimized validation of TEE quotes without relying on [attestation authority services](https://docs.trustauthority.intel.com/main/articles/introduction.html).

> ⚠️ SECURITY WARNING: This is experimental software and under development. Do not use in production.
